;; -*- coding: utf-8-unix -*-
;; History for SLIME REPL. Automatically written.
;; Edit only if you know what you're doing
("(set (first (rest list)) 'goosebump)
	   " "f" "eval f" "(first (first (rest list)))
	   " "list" "(set (first (first (rest list))) 'goosebump)
	   " "(set (first (first list)) 'goosebump)" "(first (first list))" "(setq list '(((a b) (c d) e) (f g) (h) i))" "(eval x)" "y" "x" "(set x (+ 9 2))" "(setq x 'y)" "(set 'x (+ 3 5))" "(in-package ch24)" "x1" "(psetf x1 x4 x4 x1)" "x4" "
	  " "(setf temp x1 x1 x4 x4 temp)" "x3" "(setf x0 1 x1 1 x2 (+ x0 x1) x3 (+ x2 x1) x4 (+ x3 x2))" "(log 2 3)" "(log 2 4)" "(log 1 10)" "(log 10 1)" "(log 2 2)" "e" "(defconstant e
	   2.7)" "(defconstant e
	   2.6931471806d0
	   \"Euler's constant angst\")" "(if t then 'yea else 'nope)" "(defmacro if (condition then then-clause else else-clause)
	   `(common-lisp:if ,condition ,then-clause ,else-clause))" "(defmacro if (condition then then-clause else else-clause))" "`(common-lisp:if ,condition ,then-clause ,else-clause))" "(shadow 'if)" "(shadow if)" "(shadow lisp:if)" "(pluslist-m (+ a 2) a)" "(macroexpand `(pluslist-m (+ a 2) a))" "(macroexpand `(pluslist-f (+ a 2) a))" "(macroexpand '(pluslist-f (+ a 2) a))" "(pluslist-f (+ a 2) a)" "(pluslist-f 2 a)" "(macroexpand '(pluslist-f 3 4))" "(macroexpand '(pluslist-m 3 4))" "(pluslist-m 2 a)" "a" "(setq a 9)" "(pluslist-m 2 3)" "(plus2 3 4)" "(+ \"nu\" \"a\")" "(plus2 \"nu\" \"juggallo\")" "(list 'qq 'bb 'aa)" "(defun list (&rest objects) (list objects))" "(defun list (&rest objects) (eval objects))" "(defun list (&rest objects) (eval 'objects))" "(shadow 'list)" "(shadow lisp:list)" "(shadow list)" "(defun compute (&rest expr)
	   \"Return the value of the erithmetic expression EXPR.
EXpR is to be a list containing an expression
in normal, infix notation, 
except that operators must be quoted.\"
	   (check-type expr list)
	   (eval (prefix expr)))" "(defun <= (x &rest numbers)
	   \"Returns T if x is less than or equal to the first
number in the list NUMBERS, an each number in that
list is less than or equal to the next; NIL otherwise.\"
	   (cond ((null numbers) t)
		 ((greaterp x (first numbers)) nil)
		 (t (eval `(<= ,@numbers)))))" "(defun greaterp (m n)
	   (check-type n number)
	   (check-type m number)
	   (minusp (- n m)))

" "(primes-from (lazy-first (primes-from 89 '(9 13 17 23))) (lazy-rest (primes-from 89 '(9 13 17 23))))))" "(primes-from (lazy-first (primes-from 89 '(9 13 17 23))) lazy-rest (primes-from 89 '(9 13 17 23)))))" "(primes-from (primes-from 89 '(9 13 17 23)))" "(primes-from 89 '(9 13 17 23))" "(primes-from 81 '(9 13 17 23))" "(lazy-rest (lazy-rest *))" "(lazy-first (lazy-rest *))" "(lazy-rest *)" "(primes-from 78 '(9 13 17 23))" "(primes-from 77 '(9 13 17 23))" "(lazy-rest (primes-from 77 '(9 13 17 23)))" "(relatively-prime 333324 '(377 333234 511 611 711 811 9111))" "(relatively-prime 333324 '(377 333234 5 6 7 8 9))" "(relatively-prime 333 '(377 333234 5 6 7 8 9))" "(trace floor)" "(trace #'first)" "(trace #'first))" "(trace first)" "(trace mod)" "(untrace)" "(relatively-prime 333234 '(377 4 5 6 7 8 9))" "(relatively-prime 333234 '(3 4 5 6 7 8 9))" "(mod 333234 3)" "(trace relatively-prime)" "(relatively-prime 333234 '(9 323 12 12322))" "(relatively-prime 333234 (9 323 12 12322))" "(relatively-prime 3 9)" "(relatively-prime 2 10)" "(relatively-prime 20 10)" "(mod 2 10)" "(mod 9 2)" "(mod 2 9)" "(lazy-nth 20 *)" "(fibonacci-from 0 1)" "(lazy-nth 21 *)" "(lazy-nth 8 *)" "(fibonacci-from 1 1)" "(lazy-nth 9 (natural-numbers-from 9))" "(trace lazy-rest)" "(lazy-rest (natural-numbers-from 9))" "(lazy-first (lazy-rest (natural-numbers-from 0)))" "(eval (first '(a))))" "(eval (first '(a)))" "(eval (first (a)))" "(eval ''a))" "(eval 'a)" "(eval a)" "(eval 3)" "(first '(a))" "(cons 'first '('(a)))" "(in-package ch19
		    )" "(load \"lisp/tree.lisp\")" "(match:variablep '-?orly?)" "(match:variablep '?orly?)" "(match:variablep ?orly?)" "(match:variablep \"?o rly?\")" "(load \"/Users/ohmighod/lisp/match.sse2f\")" "(load \"/Users/ohmighod/lisp/util.sse2f\")" "(import bstree)" "(import tree)" "(use-package 'tree)" "(use-package tree)" "(load-file \"tree.lisp\")" "(lazy-rest (lazy-rest (lazy-rest (natural-numbers-from 0))))" "(lazy-first (natural-numbers-from 99))" "(lazy-rest (natural-numbers-from 99))" "(natural-numbers-from 9)" "`(natural-numbers-from 9)" "(in-package cl-user)" "*package*" "`(\"me\" \"and\" ,@(list \"my\" \"shadow\"))" "`(\"me\" \"and\" `@(list \"my\" \"shadow\"))" "(cons pi (list \"are\" \"squared\"))" "(cons pi '(list \"are\" \"squared\"))" "`(cons pi ,@(list \"are\" \"squared\"))" "`(list ,@(list 'domingo 'boojr 'noether) (list 'woot 'moot 'glut))" "`(list ,(list 'domingo 'boojr 'noether) (list 'woot 'moot 'glut))" "(eql '(a (b)) '(a (b)))" "(eql 'a 'a)" "(setq zahtree (bstree-insert 'nook (bstree-insert 'moogt (bstree-insert 'loopt (bstree-insert 'hughoww (bstree-insert 'troompfth ()))))))" "(bstree-insert 'zoopt (bstree-insert 'zlaapt (bstree-insert 'zewoopt zahtree)))" "(bstree-insert 'zoopt (bstree-insert 'zlaapt (bstree-insert 'zewoopt *)))" "(bstree-insert 'nook (bstree-insert 'moogt (bstree-insert 'loopt (bstree-insert 'hughoww (bstree-insert 'troompfth ())))))" "(bstree-member 'nook *)" "(bstree-member 'cool pahtree)" "(setq pahtree (bsti 'modal (bsti 'tree (bsti 'cool (bsti 'wierdo (bsti 'har-har (bsti 'ruckus (bsti 'monnie (bsti 'abacus (bsti 'woof (bsti 'noether ())))))))))))" "pahtree" "(bstree-member 'tree mahtree)" "(bsti 'tree mahtree)" "(bsti 'monnie mahtree)" "(bsti 'modal mahtree)" "mahtree" "(bstree-right (bstree-right (bstree-right mahtree)))" "(bstree-left (bstree-right mahtree))" "(bstree-right (bstree-right mahtree))" "(bstree-right mahtree)" "(bstree-left mahtree)" "(bstree-root mahtree)" "(bstree-root (bstree-right mahtree))" "(setq mahtree (bsti 'modal (bsti 'tree (bsti 'cool (bsti 'wierdo (bsti 'har-har (bsti 'ruckus (bsti 'monnie (bsti 'abacus (bsti 'woof (bsti 'noether ())))))))))))" "(setq mahtree (bsti 'modal (bsti 'tree (bsti 'cool (bsti 'wierdo (bsti 'har-har (bsti 'ruckus (bsti 'monnie (bsti 'abacus (bsti 'woof (bsti 'noether)))))))))))" "(setq mahtree (bsti 'modal (bsti 'tree (bsti 'cool (bsti 'wierdo (bsti 'har-har (bsti 'ruckus (bsti 'monnie (bsti 'abacus (bsti 'woof (bsti noether)))))))))))" "(bsti 'modal (bsti 'tree (bsti 'cool (bsti 'wierdo (bsti 'har-har ())))))" "(bstree-root (bstree-right **))" "(bstree-right (bstree-right *))" "(bstree-member 'tree **)" "(bstree-member 'modal *)" "(bstree-member 'cool **)" "(bstree-member 'har-har **)" "(bstree-member 'wierdo *)" "(trace bstree-right)" "(in-package tree)" "(make-untagged-set '(1 2))" "(in-package set)" "(+ 1 2)" "'фф" "'aa" ":coding-system" " " "'фыва" "(getenv pwd)" "(env pwd)" "(in-package learn)" "(rekko:setp 6)" "(setp 5)" "(eql (nthcdr (length **) (append ** *)) *)" "'(1 2 3 4 5 66 )" "'(a b c rem ra rm rx)" "\"roooooooooooooooooower\"" "#\\\"" "#\\-" "#\\," "@\\-" "(char \" \" 0)" "#\\s" "#\\space" "(eq (identity *) *)")